#ifndef PARSE_H
#define PARSE_H

#include <string>
#include <iostream>
#include <list>
#include <vector>

#include <limits.h>

#include "var.h"
#include "debug.h"

class Parser {
public:
	struct Command {
		enum Type {
			SET, EXPORT, CD, ORDINARY
		};
		Type type;
		std::vector<const char *> argv;
		const char *redir[3];
	};
	typedef std::list<Command> Pipes;
	DebugStream debug;

	Parser(const VarTab& varTab) : varTab(varTab) {}
	bool parse(const char *, Pipes&);
	void reportSyntaxError(std::ostream&) const;
private:
	/* Catcode is the "category code" of a character.
	 * A character that has special lexical meanings
	 * has a catcode other than OTHER.
	 */
	enum Catcode {
		ESCAPE, EXPAND, SPACE,
		REDIR0, REDIR1, PIPE,
		LETTER, OTHER, EOL
	};
	/* LexState saves the lexical state, which contains:
	 * 1. the reading cursor;
	 * 2. the context (whether certain characters are special).
	 */
	struct LexState {
		const char *pos;
		unsigned redir:1, space:1, expand:1, escape:1;
	};
	/* The parser needs one lexical state, and also a backup
	 * in case an expansion takes place.
	 */
	LexState ls, ls_backup;

	/* varTab is the reference to the variable table in the
	 * MyShell object.  It's necessary for variable expansions.
	 * */
	const VarTab& varTab;
	/* savedStrings saves all the strings generated by the parser
	 * (e.g., program names, arguments, variable names)
	 */
	std::list<std::string> savedStrings;


	Catcode catcode(unsigned char) const;
	void doExpansion();
	bool insideExpansion() const { return ls_backup.pos != NULL; }
	bool endOfLine() const { return *ls.pos == '\0'; }
	unsigned char peek(int n = 0) const { return ls.pos[n]; }
	void next(int n = 1);
	void skipSpaces();

	const char *scanTerm();
	const char *scanName();
	int scanRedir();

	bool parsePipes(Pipes&);
	bool parseCommand(Command&);

	static Command::Type commandType(const char *);
	static bool (Parser::*const parseBuiltins[])(Command&);
	bool parseSet(Command&);
	bool parseExport(Command&);
	bool parseCd(Command&);
};


#endif /* PARSE_H */
